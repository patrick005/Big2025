//empty.h
#ifndef EMPTY_H
#define EMPTY_H

class Empty{
public:
    // Empty(){ } //in-line함수로 만든다고 알면됨 나중에 설명해줌
    // 1. 컴파일러가 자동으로 생성해주는 기본 생성자 / 클래스에 명시적인 생성자가 없을 경우 제공

    // Empty(const Empty& rhs){ /* memberwise copy*/ } //복사 생성자
    // 2. 컴파일러가 자동으로 생성해주는 복사 생성자
    // 같은 타입의 객체를 인자로 받아 멤버 변수들을 값 복사하여 새로운 객체를 생성
    // 주석 처리된 부분: Empty 클래스의 객체를 다른 Empty 객체로 초기화할 때 (Empty e2 = e1;) 컴파일러가 기본 복사 생성자를 암묵적으로 사용함

    // ~Empty(){ } //cpp 안 만들고 이렇게 써도 된다를 보여주려고 작성
    // 3. 컴파일러가 자동으로 생성해주는 소멸자 / 객체가 소멸될 때 호출
    // Empty 클래스에서는 특별한 자원 관리(동적할등 등)가 없으므로 컴파일러가 제공하는 기본 소멸자는 아무런 동작을 하지 않음

    // Empty& operator=(const Empty& rhs){ /* memberwise copy*/ return *this; } //복사 치환 연산자
    // 4. 컴파일러가 자동으로 생성해주는 복사 대입 연산자
    // 같은 타입의 객체를 인자로 받아 멤버 변수들의 값을 현재 객체에 복사
    // 주석 처리된 부분: Empty 클래스의 객체에 다른 Empty 객체를 대입할 때 (e1 = e2;) 컴파일러가 기본 복사 대입 연산자를 암묵적으로 사용함
    // *this를 반환하여 연쇄적인 대입 (e1 = e2 = e3;)이 가능
    
    // Empty* operator&(){ return this; }
    // Etc1. 객체의 주소값을 반환하는 주소 연산자 오버로딩
    // 주석 처리된 부분 &e1과 같이 객체의 주소를 얻는 연산은 컴파일러가 기본적으로 제공

    // const Empty* operator&() const{ return this; } // 함수 중복을 인자의 타입, 인자의 개수, const 유무로 다르면 사용 가능
    // Etc2. const 객체의 주소값을 반환하는 주소 연산자 오버로딩
    // const 객체에 & 연산자를 사용했을 때 호출
    // 주석 처리된 부분: const Empty 객체의 주소를 얻는 연산(&e3) 또한 컴파일러가 기본적으로 제공

    // 이동 생성자 - 수업에서 안 다뤘음
    // Empty(Empty&& rhs) noexcept { /* 멤버 이동(move) */ }
    // 5. C++11에 도입된 이동 생성자는 임시 객체의 자원을 효율적으로 이동시켜 초기화
    // Empty 클래스는 자원을 직접 관리하지 않으므로 컴파일러가 기본 이동 생성자를 생성하며, 이는 복사와 동일한 동작

    // 이동 대입 연산자 - 수업에서 안 다뤘음
    // Empty& operator=(Empty&& rhs) noexcept { /* 멤버 이동(move) */ return *this; }
    // 6. C++11에 도입된 이동 대입 연산자는 임시 객체의 자원을 효율적으로 이동시켜 현재 객체에 대입
    // Empty 클래스는 자원을 직접 관리하지 않으므로 컴파일러가 기본 이동 대입 연산자를 생성하며, 이는 복사와 동일한 동작
};

/*
중간에 Etc로 구분한 2개에 대해서 분리한 이유

수업에서 저 2개와 상위 4개를 합하여 6가지를 보여주었으나
주소 연산자 오버로딩은 컴파일러가 제공하는 기본 멤버함수에는 포함되지 않음

주소 연산자가 객체에 대해 작동한는 이유는 컴파일러가 아닌
C++언어 자체에 내장된 기본 기능이기 때문에 정상 작동하였음
operator&() 멤버 함수들은 사용자가 주소 획득 동작을 사용자 정의하고 싶을 때
명시적으로 오버로딩할 수 있는 멤버 함수이지, 컴파일러가 항상 자동으로 제공하는 기본 멤버 함수는 아님

따라서, 주석으로 다른 개념임을 구분하였으며, 미설명된 2가지에 대하여 추가하여 서술하였음
하위 2가지는 C++11부터 지원하는 형식이기에 이를 유의해야함

*/

#endif