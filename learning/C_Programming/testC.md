C프로그램 관련 내욜 작성

변수 설정 (전역변수 지역변수)
메모리에 타입을 설정해서 할당
메모리의 주소가 있다
int var_a;
var_a = 32 ;
ex) 00001이란 주소에 저장이 됐으면 &var_a를 통해서 주소에 저장된 32란 값을 불러옴

함수 scope(범위)
main(){
	int a;
.
.
.
~
}

즉, main{}안에서 지정된 것이기에 안에서만 사용가능
scanf란 함수를 사용한다면 주소를 통해 불러옴

## 1일차 학습 내용

1. 가상환경 Vmware(하드, 메모리 할당)
- window 환경에서 돌린다면 - wsl2 -> 최적화해서 실행하기에 빠름

2. Ubuntu 22.04

3. 텍스트 프로그램 
	1) nano, vi (기본 제공 프로그램 ide)
	2) vscode(확장성이 용이)
		- AI인 copilot을 연동
		- ssh 연결한 원격 작업
		- git과의 연동  (github는 클라우드 서비스)

4. c 언어

숙제0. github에 오늘 수업 다 올려라
숙제1. vscode 단축키 숙지 + 확장프로그램 확인
숙제2. README.md에서 md라는게 마크다운 문법의 요약이다
숙제3. make 문법에 대해 공부해라

ex) make 파일의 구조 – 여러 파일을 묶음명으로 지정한 후에 동일한 규칙에 대해 수행 시킴
묶음 이름: 파일명, 

규칙: 묶음이름




Vmware == 가상환경을 실행할 수 있는 도구
Virtual box etc...

환경에 대해서 설정(조성)할 때
Ex) Window -> Linux
Ubuntu == 운영체제
CLI 기반(Command line interface: 터미널 작동)이지만 GUI(Graphical User Interface) 버전에서 돌리고 있다

ubuntu와 window, mac 등 각 종류의 운영체제마다 명령어가 다르다

cd == change directory
mkdir == make directory
ls = list
gcc (옵션) (만들파일명) (대상파일이름)
-> 만들파일명 지정을 안해주면 모두 a.out으로 저장됨
***********************image*****************************
- 글자의 대소문자 구분을 하며 대부분 소문자이다

Git 명령어
git은 로컬저장소(내컴퓨터), 원격저장소로 구분된다

$git pull
 - 원격저장소에서 로컬저장소로 불러오는 명령어
$git clone (본인 git 레포지토리 주소)
$git push origin main
– 나는 add한 파일을 commit해서 메시지와 함께 원격저장소 main이라는 브런치에 올릴거야
$git add
- 파일을 원격저장소에 추가할지 정하는 명령어
$git commit –m “응애 나 코딩아가”
- 커밋시 “응애 나 코딩아가”를 메모한다

- 터미널에서의 git 연결이 안 되는 것은 password 방식이 2021년08월13일 이후로 종료되었기 때문
double과 float의 차이->변수형
main 앞과 return 뒤에 짝지어주기 int main/ void main / char main



## 2일차

# 1일차 복습
- GitHub관련 오늘 중으로 마무리 지어라 – 내가 도와서라도 끝낸다.

터미널(쉘): 우분투 서버(OS)에서 하나씩 열 수 있는 ???
터미널에서 쉘 명령어를 통해 원하는 작업을 시행한다
기본 bash 쉘을 사용하고 있다
초기 명령어

zsh(지쉘) : 쉘 명령어와 명령어를 공유하기에 차이가 없다
 - 사용할 것이라면 zsh uhmyood를 추천한다

*** 쉘 명령어를 찾아봐라 – 숙제

# C언어

- CC(컴파일) 과정
텍스트(소스)	--전처리—어셈블리 — 오브젝트 — >  바이너리 파일(실행파일)
limit.c		------------------------------>  limit : CC(컴파일)과정

위 내용을 여러 파일을 한번에 다루기 위해 makefile을 사용하였음


- 타입 Type(형) (2진수)
운영체제에 따라 데이터 크기의 변동이 있을 수 있기 때문에 type의 형태를 외울게 아니라 이해가 필요함

-- 숫자형 – 정수형	: int, char		ㄱ
	  |		  long, long long	 | -> 2의 보수를 통한 음수로 변경가능
	  ㄴ 부동소수형	: double, float		 」

	- 음수의 표현 : unsigned int


# 2일차 수업

- include#include A
#include B
에 대해 A와 B를 불러오는 것이다.
만약 A파일 안에 #include B가 있는 상태로 위와 같이 사용한다면
A와 B를 불러오는데, A안에 B를 한번 더 불러오기에 A, B, B를 불러오는 것 이기에
이러한 부분에서 include의 사용에 주의해야한다

- main 함수의 형태
int /main/()/{ return 0;}
리턴값의 타입 / 식별자(함수명) / (나중에 설명해줌) / { ~~~return (맨앞의 선언에 해당하는 데이터);}
선언의 예)
int -> 숫자
void -> 공란
char -> 문자

- Type
--    -정수형	
      ㄴ 문자형 char()
      ㄴ void	-  함수 출력을 하지 않을 때
		ㄴ 함수 입력을 안 받을 때
		ㄴ 임의의 인자를 전달*
임의의 인자: type 미정이라 뭘 줄진 몰라도 뭔갈 줄 것이기에 미리 선언이라도 한다는 느낌?


%f(실수형)이나 %lf에 대해 중간에 .(숫자)의 형태로 자리수를 지정해줄 수 있다
ex) %.2f -> 소수점 2번째 자리까지 출력
ex) %.3f -> 소수점 3번째 자리까지 출력



4. 연산자(계산)
폰 노이만 머신  -- 폰 노이만 구조 (바이트머신 : 1바이트 단위로 처리)
		ㄴ 하버드 구조

┏code		┓	 ┏ cpu ┓
┗information	┛  ->   ┗     ┛     세트로 cpu에 들어가서 처리되면 폰 노이만 구조
                      
	[code]       ┏ cpu ┓
 [information]  ->   ┗      ┛  	각 개별로 cpu에 들어가서 처리되면 하버드 구조

컴퓨터의 구조 CS(computer science) - 대학 과정일 정도로 복잡하니 알아서 찾아봐라
cpu / ram  / harddisk

변수(variable): 변화가능한 수 ┏ a
			    ┗ b
			    ┗ var_a
- 저장 가능한 메모리 공간에 확보 (식별화)
		┗ 램 ┳ 메모리 
		       | 힙 : 아무 자리에나 malloc, calloc freo의 방식으로 저장
			(자유롭다보니 메모리 리킹이 일어날 수 있음)
		      ┗ 스택 : 주로 우리가 한 코딩: 바닥에서부터 쌓아올리는 방법
		(함수 형태로 쌓아 올리다 보니 변수의 태가 변하면 치명적임)
동적할당 변수 -> 힙 방식으로 램에서 처리하는 변수

상수(constant): 코드가 변하지 않음
0 1 2 3 4 5 6 7 8 9  -> 이런 숫자에 대해 이진법으로 설명하고 일일이 만들지 않도록함
램의 메모리에 얹어버림

#include <stdio.h>
int main(void){
    int a, b;
    printf("Input a, b : ");
    scanf("%d %d", &a, &b);

    printf("PLUS %d + %d = %d\n", a, b, a+b);
    printf("MINUS %d - %d = %d\n", a, b, a-b);
    printf("MULTIPLY %d * %d = %d\n", a, b, a*b);
    printf("DIVISION %d / %d = %d\n", a, b, a/b);
    printf("나머지 %d 나머지 %d = %d\n", a, b, a%b);
    return 0;
}
# 연산자
1) 산술연산자 : +, -, *, /, %
2) 대입연산자: =
3) 복합연산자: (1),2)의 결합) +=, -=, *=, =+
4) 증감연산자: ++, --
	- 전위: ++a -> 올려서 출력해라
	- 후위: a-- -> 출력하고 올려서 저장해라


전역변수: 프로그램 끝나도 살아남음
- 자동으로 초기화가 되기 때문에 많이 사용했었음
- 해킹의 단초라 사용을 안 하는 추세
지역변수: 프로그램 끝나면 사라짐
- 가비지값이 들어가 있을 수 있기에 초기화를 해주어야 함

대입연산자가 증감연산자보다 우위임

printf("%d %d %d\n", 100, 0144, 0x64);
진수 관련 출력 방법 :
0x 로 붙으면 16진법
0o로 붙으면 8진법 옥타로 묶어라
0b로 붙으면 2진법 바이너리로 묶어라
* https://mylittlenotepad.tistory.com/88 참고

printf("%lldLL\n", 10000000000LL);
%lld-> 데이터 타입값을 long long double로 지정
“LL”은 리터럴 접미사 입니다.
크기를 명시적으로  long long을 사용했다는 것을 나타내기 위해 사용합니다
* https://dojang.io/mod/page/view.php?id=71
위 링크의 유튜브 2분 설명인데 잘 되어있어 첨부하였습니다. 한번이라도 봐주세요.

printf("%f %f\n", 2.718, 3.141592F);
f 실수형으로 표현을 한다고 뒤에 F로 명시해준 것

printf("%d %d %d\n", 'A', 'a', '0');
뒤에 A a 0라는 문자와 숫자에 대하여 숫자형으로 출력하기 위해 아스키 코드값으로 변환 후 출력

printf("%c %c %c\n", 65, 97, 48);
뒤에 숫자를 글자형으로 바꾸면 아스키 코드값에 의해 A a 0

---
//genderRatio.c
#include <stdio.h>

int main()
{
    int man, woman;
    double sum, manRate, womanRate;

    //입력받는 코드
    printf("남자의 수를 입력하시오 : ");
    scanf("%d", &man);
    printf("여자의 수를 입력하시오 : ");
    scanf("%d", &woman);
    //연산하는 코드
    sum = man + woman;
    manRate = man / sum * 100;
    womanRate = woman / sum * 100;

    printf("남자의 수는 %d명이고 여자의 수는 %d이다.\n", man, woman);
    printf("총 수는 %.f명\n남자의 비율은 %.2f%%\n여자의 비율은 %.2f%%\n", sum, manRate, womanRate);
    
    return 0;
}

==>타입 캐스팅
sum = (double)man + (doulbe)woman;


printf("총 수는 %.f명\n남자의 비율은 %.2f%%\n여자의 비율은 %.2f%%\n", sum, manRate, womanRate);

총수는 남자와 여자를 int로 선언해서 int에 해당하는 값이 나와야 하지 않나,
왜 float 형식을 쓰는가
sum = man + woman; 에서 sum이 이미 상단에서 double로 지정이 되어
%f의 타입으로 불러 줘야 합니다.
# 연산자2
1) 관계연산자: >,<,<=,>=, ==, !=
		앞, 뒤의 관계에 대해 연산하기에 두 개의 데이터가 필요하다
		이에 대한 결과는 yes나 no로 출력이 된다 ( [a<b] -> yes(1) or no(0) )

2) 논리연산자: &&(and), ||(or), !(not)
	참(yes(1))과 거짓(no(0))에 대해 연산
	yes &&(and) yes =>  yes
	yes &&(and) no =>  no
	no &&(and) yes =>  no
	no &&(and) no =>  no

	yes ||(or) yes =>  yes
	yes ||(or) no =>  yes
	no ||(or) yes =>  yes
	no ||(or) no =>  no

	!(not) yes =>  no
	!(not) no =>  yes

3) 형(Type casting)변환연산자: (new type)변수
-> 변수에 대해 (new type)으로 변경함, 밑에서 추가로 형변환이 없다면 언급한 상태로 유지
4) sizeof연산자: 결과가 몇 바이트(byte)인가에 대해 long int(%ld)의 형태로 나옴
			*8하면 비트(bite)수를 구할 수 있음
	- 힙에서의 메모리 사용시 메모리 크기(변수의 크기)가 몇 바이트인지 지정할 수 있음
int a;
sizeof(a);
->a에 대한 int로 표현시 바이트수

5) 비트연산자: &(and), ~(not), |(or), <<, >>, ^(xor)

	A: 01001110(2) 
	B: 01101010(2) -----------------------------------
	&: 01001010(2) -> and
	| : 01101110(2) -> or
	^: 00100100(2) -> xor(서로 달라야 참)

	~A : 10110001(2) -> not
      A<<1 : 10011100(2) -> 왼쪽으로 1칸씩 밀기( 밀때는 0으로, 숫자는 미는 칸 개수)
						[챕터 4-완]


   
자료형 변수명;		->초기화
변수명 = 대입값;		->할당
--> 줄여서 
자료형 변수명 = 대입값;	 -> 초기화하고 할당

자료형: int, char, double, float, char*
변수명==>사용자가 사용하고 싶은 변수의 이름
	1) 숫자로 시작 불가
	2) 예약어 사용 불가(자료형이나 main)
대입값: 넣고 싶은 값

int hellowmyfriend = 39;
float hello = 1.4;
char world = ‘A’;
char* friend = “hellow, world!”


%d => 십진수를 영어로한 decimal의 약어 / 정수(10진수 출력)
%f => float의 약자 / 소수 / 소수가 짧아도 항상 6자리까지 출력
%c => character의 약자 / 한 문자
%s => string의 약자 / 여러 문자
%o - 8진수 출력 / oct
%x - 16진수 출력 / hex


## c언어 3일차
# 흐름제어

- c언어는 기본적으로 위에서부터 내려옴
- 스레드 구분을 함 ( 스레드란 main, fucntion에 대한 구분을 지어둔 것을 말함)
- 이 흐름에 대해 특정 포인트로 점프를 하거나 뒤에 내용에 대해 스킵이 가능함


A>조건>B>레이블>C>D
조건에 대한 참 : ABCD
조건에 대한 거짓: ACD

IF ELSE / WHILE

A>레이블>B>조건>C>D
조건에 대해 참일 때, B로 점프를 시키면
ABBCD

if(조건){

}

조건에 대해 true일 때 내용물을 진행
		false일 때 if절을 패스

조건에서 0일 때만 false
0이 아닌 것들은 true

if(){}
else {}
if가 아니면 else로 이동하여 처리 후, 밑으로 내려감

if(조건1){}
elsif(조건2){}
else{}
조건1을 만족하면 if절, 조건1을 만족 못 했지만, 조건2를 만족했으면 elseif절, 조건1과 조건2를 만족 못 했으면 else절을 수행함


=========
switch

switch((int)변수){
case 1: ~
break;
case 2: ~
break;
}
switch 변수에 해당하는 번호의 case에서 작업을 수행함
break;를 넣어서 swith에서 속한 내용을 수행후 탈출함/안쓰면 무한루프문



=============
a
while(조건문){

b
}
while의 조건은 연속체크
a > 조건참 > b > 조건참 > b
조건을 계속 돌려서 조건이 거짓이 될 때까지 반복
주로 b자리에 if(조건문)을 넣어서 조건을 만족하면 break하도록 설정을 함


==========
삼항연산자 (if~esle~) 
조건 ? 문장1 : 문장2
조건에 대하여 참이면 문장1, 거짓이면 문장2
조건문의 형식이 아닌 연산자로 표현이 가능하다


for문
for(문장1; 문장2; 문장3)
문장1 : 초기화 – 처음 시작할 때 한번 함, 반복에 적용하진 않음
문장2 : 조건문 – 참 거짓으로 구분, 참일시 조건절 시행문장3 : 조건절을 시행한 후, 증감 연산자에 대한 내용을 시행



컴퓨터 관련해서는 0부터 출발하는 것이 대부분이기에 무언가 하는거에 대해 0부터 시작하는 것을 몸에 길들였으면 좋겠다.

식별자를 사용할 때
의미가 있는 음절단위로 대문자로 표기하는 방법에 대해 낙타표기법

camel case
leafYear--->sql 때도 설명 했던 부분

upper case
#define 뒤에 나올 식별자에 대해서는 전부 대문자로 저장해서 가져옴

*snake case (파이썬에서 사용)
음절단위 _를 넣어주는 방법 leaf_year

코딩을 할 때 type에 대해 (int, float, char, 등등)
->내장 타입이라 소문자를 사용하여도 정상 작동함
->사용자 정의의 타입에 대해서는 Mytype에 대해선 시작을 대문자로함


일경험으로 수당이 나오니 프로젝트에 들어갈 돈에 대해 미리 마련할 수단이 있음
이에 대해 수업 끝나고 설명함

## c언어 3일차 – 복습
실행 흐름 – 시간
하드웨어적으로 : 크리스탈 오실레이터(진동자) -> CPU클럭
 => 크리스탈 33MHz, 133MHz, 2.5GHz
thred(실)-> 특정 지점으로 점프나 회귀, 조건에 따른 각기 다른 지점으로 이동

# 조건문(앞으로 점프)
1) if문 / if~else~문/ if~else if~else~(if~else~의 이중 사용)문
2) switch~case~default문 (break를 사용하여 해당 case에서 탈출)

# 반복문(뒤로 점프)
1) for(초기화; 조건; 증감)문
- 증감은 필수 사항이 아니라 그냥 닫아도 된다
- 개수에 대해 체크를 잘 해야한다.

## c언어 4일차

## 반복문
# while문
형식: while(true/false){        }
true, false로 쓰면 break를 사용하기 위해 조건을 안에 넣어줘야한다.
true, false자리에 조건을 넣어주면 break를 위한 조건을 상황에 따라 안 넣어도 된다.

# do while
do 절에 반복할 내용을 걸고, while에 조건을 넣는다.
형식: do{반복할 내용}while(조건);
- 자주 사용하진 않음
- 조건이 아닌 값이 들어오더라도 한 번은 시행함
- 조건에 상관없이 한 번이라도 시행하고 그뒤로 조건을 적용하고 싶을 때 사용함








## 함수(function)
- 반복적인 코드를 묶어서 실행한다
- ex) printf

# 변수
전역변수 / 지역변수 / 정적 지역변수(static)
지역변수는 해당 절에서만 적용되기에 휘발성이다
해당 절이나 함수가 몇 번 시행되었는지 확인하는 것을 만든다고 할 때, 휘발되면 안되는 변수기에 정적 지역변수로 지정을 해준다
정적지역변수는 전역변수의 기능을 수행한다

#include
전역변수(global)
main함수{
지역변수(local)
}
function1{
지역변수
}

메모리 영역
들어가는 것
코드
프로그램 코드, 함수, 상수
데이터
전역변수, (정적 지역변수)static int
힙

스택(휘발성)
지역변수, const int



## 배열(Array)
- 연속된 같은 type의 자료

int a1; ->
int a2; ->

int arr[5]; -> ㅁㅁㅁㅁㅁ 할당 -> 주소값이 순차적으로 붙음
int arr[5] = {0, 1, 2, 3, 4}
int arr[] = {0, 1, 2, 3, 4}
int arry[5] = {0}
다른폴더에 데이터값 가져와서 써먹는 명령어
**************image*******************
./average2022Temp < temp2022.dat

<을 통한 .dat에 적용된 데이터값을 scanf로 받음
배열 포멧을 했으면 부족한 수량의 데이터값은 0의 값에서 변동이 없음
배열 포맷을 한 상태에서 초과된 데이터에 대해서 미처리





